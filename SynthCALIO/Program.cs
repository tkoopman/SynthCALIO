using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Text.RegularExpressions;

using Common;

using CsvHelper;

using Mutagen.Bethesda;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;

using Noggog;

using SynthCALIO.Outputs;

namespace SynthCALIO
{
    public partial class Program
    {
        public const char OptionalPrefix = '?';

        internal static Lazy<Settings> Settings = null!;
        internal static IPatcherState<ISkyrimMod, ISkyrimModGetter> State = null!;

        private static readonly CsvHelper.Configuration.CsvConfiguration csvConfig = new(CultureInfo.InvariantCulture)
        {
            HasHeaderRecord = false,
            Delimiter = "\t",
            DetectDelimiter = true,
            TrimOptions = CsvHelper.Configuration.TrimOptions.Trim,
            IgnoreBlankLines = true,
            BadDataFound = null,
            AllowComments = true,
            Comment = '#',
        };

        private static readonly List<string> outputtedFiles = [];
        private static DirectoryPath DataFolder;
        private static bool isSafeOutput = false;
        private static JsonConfig jsonConfig = null!;
        private static FileName modFilename;
        private static uint nextFormID = 0;
        private static DirectoryPath outputDir;
        private static FilePath spidFile;
        public static UVDictionary<uint, string> FormIDCache { get; set; } = new(null, StringComparer.OrdinalIgnoreCase);
        public static UVDictionary<uint, string> ThisRunsCache { get; set; } = new(null, StringComparer.OrdinalIgnoreCase);

        public static uint GetFormID (string editorID)
        {
            if (FormIDCache.TryGetKey(editorID, out uint formID))
            {
                return ThisRunsCache.TryAdd(formID, editorID) ? formID : throw new InvalidDataException($"Failed to add {editorID} ({formID}) to cache");
            }
            else
            {
                uint id = nextFormID++;
                return FormIDCache.TryAdd(id, editorID) && ThisRunsCache.TryAdd(id, editorID) ? id : throw new InvalidDataException($"Failed to add {editorID} ({id}) to cache");
            }
        }

        public static async Task<int> Main (string[] args) => await SynthesisPipeline.Instance
            .SetAutogeneratedSettings(nickname: "SynthCALIO Settings", path: "settings.json", out Settings)
            .AddRunnabilityCheck(loadConfigAndCheckRunnability)
            .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
            .SetTypicalOpen(GameRelease.SkyrimSE, "SynthCALIO.esp")
            .Run(args);

        public static void RunPatch (IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            State = state;
            if (State.PatchMod.EnumerateMajorRecords().Any())
                throw new InvalidOperationException("SynthCALIO must be the first patch in a Synthesis' Group.");

            modFilename = state.ExtraSettingsDataPath?.Name ?? throw new DirectoryNotFoundException("ExtraSettingsDataPath not found");
            modFilename += state.PatchMod.ModKey.FileName.Extension;

            loadFormIDCache();
            if (Settings.Value.UpdateCache)
                generateFormIDCache();

            Console.WriteLine($"Loaded {FormIDCache.Count} FormIDs from cache");
            nextFormID = FormIDCache.Keys.Count == 0 ? State.PatchMod.NextFormID : FormIDCache.Keys.Max() + 1;

            spidFile = outputDir.GetFile($"{modFilename.NameWithoutExtension}_DISTR.ini");
            Console.WriteLine($"SPID output file: {spidFile}");

            using var writer = new StreamWriter(spidFile, false);
            writer.WriteLine("; Generated by SynthCALIO");

            createLeveledItems(writer);
            createOutfits(writer);
            processOutputs(writer);

            writer.Close();
            writeFormIDCache();
        }

        /// <summary> Similar to Common.TryGetRecord<> but first checks cache from this run, to make
        /// sure if it was created in this run we use that entry and don't accidentally find some
        /// other random entry. </summary>
        public static bool TryGetRecord<T> (string id, [NotNullWhen(true)] out T? record)
            where T : class, IMajorRecordQueryableGetter
        {
            record = null;

            return SynthCommon.TryConvertToSkyrimID(id, out var formKey, out string editorID) switch
            {
                SkyrimIDType.FormKey => State.LinkCache.TryResolve<T>(formKey, out record),
                SkyrimIDType.EditorID => ThisRunsCache.TryGetKey(editorID, out uint formID) ? State.LinkCache.TryResolve<T>(new FormKey(State.PatchMod.ModKey, formID), out record) : State.LinkCache.TryResolve<T>(editorID, out record),
                _ => false,
            };
        }

        internal static string formatSPID (string input, FormKey formKey, string defaultFormType, string? fromFile = null)
        {
            var m = RegexSPID().Match(input);
            if (!m.Success)
                throw new InvalidDataException($"Could not phrase SPID entry {input}. File: {fromFile}");

            string formType = m.Groups.TryGetValue("FormType", out var g1) && !string.IsNullOrWhiteSpace(g1.Value) ? g1.Value : defaultFormType;
            string spid = m.Groups.TryGetValue("SPID", out var g2) && !string.IsNullOrWhiteSpace(g2.Value) ? g2.Value :throw new InvalidDataException($"Invalid SPID entry {input}. File: {fromFile}");

            return $"{formType} = 0x{formKey.ID:X}~{formKey.ModKey}|{spid}";
        }

        private static void createLeveledItems (StreamWriter writer)
        {
            bool addedSPID = false;

            // Sort LeveledItem list so that we create any that contain entries to others after the
            // others created
            List<JsonLeveledItem> sorted = [];
            var linked = jsonConfig.LeveledItems;

            while (linked.Count != 0)
            {
                var referenced = linked
                    .SelectMany(x => x.AllEntries.SelectMany(y => y)) // Return all entries from all LeveledItems
                    .Select(x => x.ID) // Just need ID from each entry
                    .Where(x => !x.Contains(':')) // Exclude FormKey entries
                    .ToHashSet(StringComparer.OrdinalIgnoreCase); // Only unique

                var split = linked.GroupBy(x => referenced.Contains(x.EditorID));
                var notLinked = (split.FirstOrDefault(x => !x.Key)?.ToList()) ?? throw new InvalidDataException("Circular reference found in LeveledItems");

                notLinked.Sort((lhs, rhs) => string.Compare(rhs.EditorID, lhs.EditorID, StringComparison.OrdinalIgnoreCase));
                sorted.AddRange(notLinked);
                linked = (split.FirstOrDefault(x => x.Key)?.ToList()) ?? [];
            }

            sorted.Reverse();
            foreach (var jsonLeveledItem in sorted)
            {
                var lvlItem = jsonLeveledItem.ToLeveledItem();

                if (lvlItem is not null)
                {
                    State.PatchMod.LeveledItems.Add(lvlItem);
                    Console.WriteLine($"Added LeveledItem: {lvlItem.EditorID} [{lvlItem.FormKey}]");

                    if (jsonLeveledItem.SPID.Length > 0)
                    {
                        if (!addedSPID)
                        {
                            writer.WriteLine();
                            writer.WriteLine("; Items");
                            addedSPID = true;
                        }

                        if (Settings.Value.IncludeEditorID)
                        {
                            writer.WriteLine();
                            writer.WriteLine($"; {lvlItem.EditorID}");
                            addedSPID = true;
                        }
                    }

                    foreach (string spid in jsonLeveledItem.SPID)
                        writer.WriteLine(formatSPID(spid, lvlItem.FormKey, "Item"));
                }
            }
        }

        /// <summary>
        ///     Creates and assigns outfits to NPCs.
        /// </summary>
        private static void createOutfits (StreamWriter writer)
        {
            bool addedSPID = false;

            jsonConfig.Outfits.Sort((lhs, rhs) => string.Compare(lhs.EditorID, rhs.EditorID, StringComparison.OrdinalIgnoreCase));

            foreach (var jsonOutfit in jsonConfig.Outfits)
            {
                var outfit = jsonOutfit.ToOutfit();

                if (outfit is not null)
                {
                    State.PatchMod.Outfits.Add(outfit);
                    Console.WriteLine($"Added outfit: {outfit.EditorID} [{outfit.FormKey}]");

                    foreach (string npcOutfit in jsonOutfit.DefaultOutfit)
                    {
                        if (SynthCommon.TryGetRecordContext<INpc, INpcGetter>(npcOutfit, State.LinkCache, out var context))
                        {
                            var patchRecord = context.GetOrAddAsOverride(State.PatchMod);
                            patchRecord.DefaultOutfit = outfit.ToNullableLink();

                            Console.WriteLine($"    Added as DefaultOutfit to {patchRecord.Name} [{patchRecord.FormKey}]");
                        }
                        else
                        {
                            Console.WriteLine($"    Failed to add as DefaultOutfit to {npcOutfit}");
                        }
                    }

                    foreach (string npcOutfit in jsonOutfit.SleepingOutfit)
                    {
                        if (SynthCommon.TryGetRecordContext<INpc, INpcGetter>(npcOutfit, State.LinkCache, out var context))
                        {
                            var patchRecord = context.GetOrAddAsOverride(State.PatchMod);
                            patchRecord.SleepingOutfit = outfit.ToNullableLink();

                            Console.WriteLine($"    Added as SleepingOutfit to {patchRecord.Name} [{patchRecord.FormKey}]");
                        }
                        else
                        {
                            Console.WriteLine($"    Failed to add as SleepingOutfit to {npcOutfit}");
                        }
                    }

                    if (jsonOutfit.SPID.Length > 0)
                    {
                        if (!addedSPID)
                        {
                            writer.WriteLine();
                            writer.WriteLine("; Outfits");
                            addedSPID = true;
                        }

                        if (Settings.Value.IncludeEditorID)
                        {
                            writer.WriteLine();
                            writer.WriteLine($"; {outfit.EditorID}");
                            addedSPID = true;
                        }
                    }

                    foreach (string spid in jsonOutfit.SPID)
                        writer.WriteLine(formatSPID(spid, outfit.FormKey, "Outfit"));
                }
            }

            if (addedSPID)
                writer.WriteLine();
        }

        /// <summary>
        ///     Update loaded FormID cache with entries from the current version of this patcher's
        ///     mod. Should override any existing EditorID entries with the new FormID.
        /// </summary>
        private static void generateFormIDCache ()
        {
            var path = State.DataFolderPath.GetFile(State.OutputPath.Name);

            if (!path.Exists)
            {
                Console.WriteLine($"Could not find mod: {path.Name}");
                return;
            }

            Console.WriteLine($"Attempting to generate output cache from {path.Name}");

            var mod = SkyrimMod.CreateFromBinary(path, State.GameRelease.ToSkyrimRelease());

            foreach (var record in mod.EnumerateMajorRecords())
            {
                if (record.EditorID.IsNullOrWhitespace() || !record.FormKey.ModKey.Equals(mod.ModKey))
                    continue;

                if (!FormIDCache.TryUpdateOrAdd(record.FormKey.ID, record.EditorID))
                    throw new InvalidDataException($"Failed to add FormID {record.EditorID} ({record.FormKey}) to cache");
            }
        }

        /// <summary>
        ///     Load and check the validity of the configuration files. Doesn't check for listed
        ///     EditorIDs or FormKeys actually existing, just that the config file format is
        ///     correct.Should throw exception if any issues are found to stop Synthesis from
        ///     starting the actual patch run, as this a Runnability Check for this patcher.
        /// </summary>
        private static void loadConfigAndCheckRunnability (IRunnabilityState state)
        {
            string dataFolder = Program.Settings.Value.Folder;
            dataFolder = dataFolder.Replace("{SkyrimData}", state.DataFolderPath);
            DataFolder = dataFolder.Replace("{SynthesisData}", state.ExtraSettingsDataPath);

            jsonConfig = new JsonConfig();

            jsonConfig.LoadConfigurationFiles(state, dataFolder);

            outputDir = string.IsNullOrWhiteSpace(Settings.Value.Output)
                ? state.DataFolderPath
                : new DirectoryPath(Settings.Value.Output).MakeAbsolute();

            isSafeOutput = !outputDir.Equals(state.DataFolderPath);

            if (!outputDir.Exists)
                throw new FileNotFoundException("Unable to find output path.", outputDir);

            if (!isSafeOutput)
                Console.WriteLine($"Output path is same as your Skyrim Data folder. As such SynthCALIO will not delete extra output files that may of had SynthCALIO configs removed, as no way to know if created by SynthCALIO");

            Console.WriteLine($"Output path for extra files: {outputDir}");
        }

        /// <summary>
        ///     Loads the FormID cache from the CSV data file saved in previous runs.
        /// </summary>
        private static void loadFormIDCache ()
        {
            if (State.ExtraSettingsDataPath is null)
                return;

            string path = Path.Combine(State.ExtraSettingsDataPath, "formIDCache.txt");

            if (!Path.Exists(path))
            {
                Console.WriteLine($"Could not find FormID cache: {path}");
                return;
            }

            Console.WriteLine($"Loading FormID cache from {path}");

            using (var reader = new StreamReader(path))
            using (var csv = new CsvReader(reader, csvConfig))
            {
                while (csv.Read())
                {
                    _ = csv.TryGetField(0, out string? key) && csv.TryGetField(1, out string? value) && !string.IsNullOrWhiteSpace(value)
                        ? FormIDCache.TryAdd(Convert.ToUInt32(key, 16), value)
                        : throw new InvalidDataException("FormID cache contains invalid entry.\n" + csv.Parser.RawRow);
                }
            }
        }

        private static void processOutputs (StreamWriter writer)
        {
            DirectoryPath outputsDir = Path.Combine(DataFolder, "Outputs");
            var configParser = ConfigParser.FromFile(DataFolder.GetFile("Outputs.ini"));
            if (!outputsDir.Exists)
                return;

            if (!isSafeOutput)
            {
                Console.WriteLine("""
                        WARNING: Output folder is set to game's data folder. Not able to clear out potentially no longer required output files.
                                 You should manually check the output folder for any files that are no longer needed and delete them.
                        """);
            }
            else if (!Settings.Value.OutputClear)
            {
                Console.WriteLine("""
                        WARNING: You have disabled clearing out potentially no longer required output files.
                                 Files that would of been deleted will just be listed below. You will have to delete them manually.
                        """);
            }

            Console.WriteLine("");

            foreach (var file in outputsDir.EnumerateFiles(recursive: true))
            {
                string relFile = file.GetRelativePathTo(outputsDir);
                using var fileStream = File.OpenText(file);
                string? line = fileStream.ReadLine();
                fileStream.Close();
                var config = configParser.FindConfig(relFile, line);
                if (config is null)
                {
                    Console.WriteLine($"Skipping file as no outputs configuration found. File: {relFile}");
                    continue;
                }

                if (!config.IsValid())
                {
                    Console.WriteLine($"Skipping file as FormID not set. File: {relFile}");
                    continue;
                }

                if (config.TryReplaceText(File.ReadAllText(file), relFile, modFilename, ThisRunsCache.Swap(), out string? contents, out string outputPath))
                {
                    var outFile = outputDir.GetFile(outputPath);

                    if (outFile == spidFile)
                    {
                        writer.WriteLine(contents);
                        continue;
                    }

                    if (!outputtedFiles.Contains(outFile.ToString(), StringComparer.OrdinalIgnoreCase))
                    {
                        Console.WriteLine($"Outputting: {relFile}");
                        outputtedFiles.Add(outFile.ToString());
                        outFile.Delete();
                    }

                    outFile.Directory?.Create();

                    using var fileWriter = new StreamWriter(outFile, true);
                    fileWriter.Write(contents);
                    fileWriter.Close();
                }
            }

            if (isSafeOutput)
            {
                foreach (var file in outputDir.EnumerateFiles(recursive: true))
                {
                    if (file.ToString().Equals(spidFile.ToString(), StringComparison.OrdinalIgnoreCase))
                        continue;

                    if (outputtedFiles.Contains(file.ToString(), StringComparer.OrdinalIgnoreCase))
                        continue;

                    string relFile = file.GetRelativePathTo(outputDir);

                    if (configParser.CouldMatch(relFile))
                    {
                        if (Settings.Value.OutputClear)
                        {
                            Console.WriteLine($"Deleting: {relFile}");
                            file.Delete();
                        }
                        else
                        {
                            Console.WriteLine($"Skipped deleting: {relFile}");
                        }
                    }
                }
            }
        }

        [GeneratedRegex(@"^(?:(?'FormType'[\w]+) ?= ?\|)?(?'SPID'(?:[^\|=]*\|){0,5}[^\|=]*)$")]
        private static partial Regex RegexSPID ();

        private static void writeFormIDCache ()
        {
            if (State.ExtraSettingsDataPath is null)
                return;

            if (!Path.Exists(State.ExtraSettingsDataPath))
            {
                Console.WriteLine($"Could not find data folder: {State.ExtraSettingsDataPath}");
                return;
            }

            string path = Path.Combine(State.ExtraSettingsDataPath, "formIDCache.txt");

            Console.WriteLine($"Writing FormID cache to {path}");
            using (var writer = new StreamWriter(path, false))
            using (var csv = new CsvWriter(writer, csvConfig))
            {
                foreach (var entry in FormIDCache)
                {
                    csv.WriteField(entry.Key.ToString("X3"));
                    csv.WriteField(entry.Value);
                    csv.NextRecord();
                }
            }
        }
    }
}